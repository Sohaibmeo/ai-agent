0. Tech Stack (for Codex)

Frontend: React + TypeScript

Backend: Node.js + TypeScript + Express (or similar)

DB: Postgres

LLM orchestration: LangChain JS + OpenAI / local OpenAI-compatible model

Validation: Zod

1. System Overview

Build a UK-focused AI meal planner that:

Collects user profile & preferences

Generates 7-day meal plans that respect budget, diet, difficulty, and portion mode

Allows deep plan editing (ingredient/meal/day/week)

Produces a grocery list based on the plan

Lets users override ingredient prices and track pantry items

Uses Coach Agent + Review Agent (LangChain) to generate and modify plans

Provides a dashboard UI with left navigation tabs:

Profile

Plans

Groceries

2. Frontend Structure & Flows
2.1 Overall Layout

A Dashboard layout with:

Left sidebar navigation (vertical tabs)

Main content area on the right

Left Sidebar Tabs

Profile

Plans

Groceries

User lands on Profile when visiting the app for the first time. They can always come back to change preferences.

2.2 Profile Page (Tab: “Profile”)

This is the onboarding + settings page.

Sections

Basic Info

Age (number)

Height (cm)

Weight (kg)

Activity level (dropdown: sedentary / light / moderate / active)

Dietary Requirements

Select one: none / halal / vegan / vegetarian / keto / gluten-free / lactose-free

Internally maps to ingredient avoid lists (e.g. halal → no pork/alcohol)

Preferences

Ingredients preferred (multi-select / tags input)

Ingredients to avoid

Must-have ingredients

Recipes preferred (optional)

Cuisines liked

Cuisines disliked

Meal Schedule

Toggles:

Breakfast: ON/OFF

Snacks: ON/OFF

Lunch: ON/OFF

Dinner: ON/OFF

Difficulty & Portion Mode

Recipe difficulty: super easy / easy / medium / hard

Portion mode:

Cutting

Maintenance

Bulking

Weekly Budget

Numeric input in GBP (optional but recommended)

Backend

GET /api/user/profile → load existing profile & preferences

PUT /api/user/profile → save all profile + preference data in one go

2.3 Plans Page (Tab: “Plans”)

This page is both:

Plans overview (history)

Current plan view + controls

Layout

Top section: “Generate / Current Plan”

Button: “Generate New Week”

If a current plan exists:

Show summary card:

Week starting date

Total estimated cost

Total calories

Status (draft / active)

Button / link: “View Full Plan” (or show directly below)

Middle/Lower section: “Plan History”

List of past plans:

Week start date

Status (active / superseded)

Summary cost and calories

Click to view details (read-only)

Current Plan Detail View

This is where all the AI + interaction lives.

Structure:

Weekly header:

Week dates

Total cost, total kcal

Small note: “All values are estimates”

For each day (0–6):

Day label (e.g. Monday, etc.)

Daily cost & daily kcal

Within each day: list of meals in order (breakfast, snack, lunch, dinner if enabled)

Each meal card shows:

Meal name (recipe name)

Macros summary

Estimated cost

Portion info (e.g. “1.2x portion (bulking)”)

Regenerate icon (e.g. a small circular arrow in top-right of the meal card)

Under each meal, show ingredients:

For each ingredient row, show:

Name

Quantity + unit

Cost (optional)

Text actions (no buttons, just clickable inline text):

remove → remove ingredient from this meal

swap → open a small menu or just trigger default swap alternatives

avoid in future → adds to preference avoid list

prefer in future → adds to preference preferred list

All these text actions should look like links (e.g. underlined or secondary text style).

Plan Interactions (how user triggers flows)

At different levels:

Week level:

Text link like: “Regenerate whole week”

Text link: “Swap all [ingredient] this week” (e.g. UI that lets you choose an ingredient name from a dropdown)

Dropdown or section to change portion mode or difficulty for the whole week (optional for v1, but spec supports it)

Day level:

Text like: “regenerate this day” (positioned near the day heading)

Meal level:

Regenerate icon (top-right of meal card)

Clicking shows a small menu:

“healthier”

“cheaper”

“higher protein”

“easier to cook”

“turn into smoothie/drinkable” (if applicable)

Ingredients list with inline text actions:

remove, swap, avoid in future, prefer in future

When user clicks any of these, frontend calls:

POST /api/plan/action with:

{
  "userId": "...",
  "weeklyPlanId": "...",
  "actionContext": {
    "type": "regenerate_meal" | "regenerate_day" | "regenerate_week" | "swap_all_ingredient" | "remove_ingredient",
    "planDayId": "...",
    "planMealId": "...",
    "ingredientId": "...",
    "ingredientName": "mayonnaise"
  },
  "reasonText": "optional explanation from user"
}

The backend + agents handle the rest.

2.4 Groceries Page (Tab: “Groceries”)

This page shows the shopping list for the current plan (or selected plan).

Layout:

Dropdown / selector: “Select week” (defaults to current active plan)

Shows Shopping List grouped by category:

Meat & Fish

Dairy & Eggs

Grains & Pasta

Vegetables & Fruits

Pantry & Spices

Other

For each ingredient item:

Name

Required quantity + unit

Estimated cost

Checkbox:

[ ] I already have this

Text link:

update price → user enters price for some quantity they bought

Actions update:

pantry_items when “I already have this” is checked

user_ingredient_price when price updated

Backend endpoints:

GET /api/shopping-list?weeklyPlanId=...

POST /api/shopping-list/mark-have

POST /api/shopping-list/update-price

3. Agents & Orchestrator

(Backend + LangChain JS)

3.1 Agents
Coach Agent

Implemented using LangChain JS (ChatOpenAI or local).

Uses Zod + StructuredOutputParser to return WeeklyPlan JSON.

Tasks:

Generate full 7-day plan from GenerateWeekInput + catalog.

Modify an existing plan based on a ReviewInstruction.

Respect:

diet_type

ingredients avoid/prefer

difficulty

portion_mode

weekly_budget_gbp

meal schedule (breakfast/snack/lunch/dinner)

Review Agent

Implemented as another LangChain chain.

Takes:

actionContext (type + target IDs + optionally ingredient name)

reasonText

currentPlan

profileSnippet (diet, difficulty, budget, portionMode)

Outputs a ReviewInstruction JSON that guides Coach Agent.

Examples:

swap_all_ingredient → action: "swap_ingredient", params: { ingredientToRemove, applyToWholeWeek: true }

regenerate_meal with “make healthier” → action: "regenerate_meal", params: { makeHealthier: true, keepCaloriesSimilar: true }

3.2 Orchestrator Functions

Implement in src/llm/orchestrator.ts:

generateWeeklyPlan(userId: string): Promise<WeeklyPlan>

Load user profile + preferences from DB.

Build GenerateWeekInput.

Build a compact catalog from recipes + ingredients (with effective prices).

Call coachChain.invoke({ input }).

Validate & persist WeeklyPlan to DB:

weekly_plans, plan_days, plan_meals, plan_meal_ingredients

Build shopping list for the plan.

Return persisted plan (for frontend).

handlePlanAction(...)

Signature:

handlePlanAction({
  userId,
  weeklyPlanId,
  actionContext,
  reasonText
}): Promise<WeeklyPlan>

Flow:

Load current plan from DB.

If action type is accept_week:

mark plan active and return.

Build profileSnippet.

Call Review Agent with:

actionContext, reasonText, currentPlan, profileSnippet.

Get ReviewInstruction.

Build catalog.

Call Coach Agent with:

mode: "regenerate"

currentPlan

instruction = ReviewInstruction

catalog

Get updated WeeklyPlan JSON.

Persist changes in DB (update plan tables).

Rebuild shopping list for this plan.

Return updated plan.

4. Database Schema (Summary)

Use Postgres and create these tables (structure simplified from earlier):

users

user_profile

user_preferences

ingredients

user_ingredient_price

recipes

recipe_ingredients

weekly_plans

plan_days

plan_meals

plan_meal_ingredients

pantry_items

shopping_list_items

plan_feedback (optional, to log actions/learning)

(You can use the detailed SQL from the previous spec; structure is unchanged.)

5. JSON & Zod Schemas (Core)

Use these for LLM outputs and frontend types.

Weekly Plan Types

export interface IngredientRef {
  id: string;
  name: string;
  quantity: number;
  quantityUnit: string;
  kcal?: number;
  protein?: number;
  carbs?: number;
  fat?: number;
  estimatedCost?: number;
}

export interface PlanMeal {
  id: string;
  mealType: "breakfast" | "snack" | "lunch" | "dinner";
  recipeId: string | null;
  recipeName: string;
  portionMultiplier: number;
  kcal?: number;
  protein?: number;
  carbs?: number;
  fat?: number;
  estimatedCost?: number;
  ingredients: IngredientRef[];
}

export interface PlanDay {
  id: string;
  dayIndex: number;
  date?: string;
  meals: PlanMeal[];
  dailyEstimatedCost?: number;
  dailyKcal?: number;
}

export interface WeeklyPlan {
  id: string;
  userId: string;
  weekStartDate: string;
  status: "draft" | "active" | "superseded";
  days: PlanDay[];
  totalEstimatedCost?: number;
  totalKcal?: number;
}

GenerateWeekInput
export interface GenerateWeekInput {
  userId: string;
  profile: {
    age?: number;
    heightCm?: number;
    weightKg?: number;
    activityLevel: "sedentary" | "light" | "moderate" | "active";
    dietType:
      | "none"
      | "halal"
      | "vegan"
      | "vegetarian"
      | "keto"
      | "gluten_free"
      | "lactose_free";
    recipeDifficulty: "super_easy" | "easy" | "medium" | "hard";
    portionMode: "cutting" | "maintenance" | "bulking";
    weeklyBudgetGbp?: number;
    enableBreakfast: boolean;
    enableSnacks: boolean;
    enableLunch: boolean;
    enableDinner: boolean;
  };
  preferences: {
    ingredientsPreferred: string[];
    ingredientsAvoid: string[];
    mustHaveIngredients: string[];
    recipesPreferred: string[];
    cuisinesLiked: string[];
    cuisinesDisliked: string[];
  };
}

ReviewInstruction
export interface ReviewInstruction {
  targetLevel: "week" | "day" | "meal" | "ingredient";
  targetIds?: {
    weeklyPlanId?: string;
    planDayId?: string;
    planMealId?: string;
    ingredientId?: string;
  };
  action:
    | "generate_new_week"
    | "regenerate_week"
    | "regenerate_day"
    | "regenerate_meal"
    | "swap_ingredient"
    | "remove_ingredient";
  params?: {
    ingredientToRemove?: string;
    ingredientToAdd?: string;
    applyToWholeWeek?: boolean;
    makeHealthier?: boolean;
    makeCheaper?: boolean;
    makeHigherProtein?: boolean;
    easierDifficulty?: boolean;
    preferMealType?: "drinkable" | "solid";
    keepCaloriesSimilar?: boolean;
  };
}
And the equivalent Zod schemas (from previous answer) should be in src/llm/schemas.ts.

Instructions :
Make sure to keep the code cleaner. files should be divided properly.
Commit changes with real based messages based on content naturally

Structure :
src/
  server.ts
  api/
    userRoutes.ts
    planRoutes.ts
    shoppingListRoutes.ts
  db/
    index.ts
    repositories/
      userRepo.ts
      planRepo.ts
      ingredientRepo.ts
      recipeRepo.ts
      shoppingListRepo.ts
  llm/
    llmClient.ts
    schemas.ts
    coachAgent.ts
    reviewAgent.ts
    orchestrator.ts

llm/schemas.ts → contains the Zod + TS types for WeeklyPlan, GenerateWeekInput, ReviewInstruction.

llm/llmClient.ts → exports a createLLM() that returns a LangChain ChatOpenAI (or compatible) instance using env vars.

llm/coachAgent.ts → defines the Coach Agent LangChain chain with StructuredOutputParser using WeeklyPlanSchema.

llm/reviewAgent.ts → defines the Review Agent LangChain chain with StructuredOutputParser using ReviewInstructionSchema.

llm/orchestrator.ts → exports generateWeeklyPlan and handlePlanAction, and must call the Coach + Review chains.

6.2 LLM client (llmClient.ts)

Use LangChain JS:

// src/llm/llmClient.ts
import { ChatOpenAI } from "@langchain/openai";

export function createLLM() {
  return new ChatOpenAI({
    model: process.env.LLM_MODEL || "gpt-4.1-mini",
    temperature: 0.4,
    // baseURL: process.env.LLM_BASE_URL, // if using local OpenAI-compatible server
  });
}


6.3 Coach Agent (coachAgent.ts)

Must use WeeklyPlanSchema + StructuredOutputParser to enforce strict JSON.

Must accept an input object containing:

mode: "generate" | "regenerate"

generateInput (for “generate” mode)

currentPlan (for “regenerate” mode)

instruction (ReviewInstruction, for regenerations)

catalog (recipes + ingredients summary)

Returns a WeeklyPlan object that passes Zod validation.

6.4 Review Agent (reviewAgent.ts)

Must take { actionContext, reasonText, currentPlan, profileSnippet } as input.

Must output a valid ReviewInstruction JSON using ReviewInstructionSchema + StructuredOutputParser.

6.5 Orchestrator (orchestrator.ts)

generateWeeklyPlan(userId):

reads user profile + preferences from DB

builds GenerateWeekInput

builds catalog from recipes + ingredients (with effective price per unit for that user)

calls coachChain.invoke({ input })

validates with WeeklyPlanSchema

persists to weekly_plans, plan_days, plan_meals, plan_meal_ingredients

calls shopping list service to create entries in shopping_list_items

returns the persisted WeeklyPlan for API.

handlePlanAction({ userId, weeklyPlanId, actionContext, reasonText }):

loads current plan from DB

if actionContext.type === "accept_week": mark plan active and return

builds profileSnippet (diet, difficulty, budget, portionMode)

calls Review Agent → gets ReviewInstruction

builds catalog

calls Coach Agent with mode "regenerate" and instruction

persists updated plan and updates shopping list

returns updated plan.

6.6 API routes must call orchestrator (planRoutes.ts)

POST /api/plan/generate-week → calls generateWeeklyPlan(userId)

POST /api/plan/action → calls handlePlanAction(...)

GET /api/plan/current + GET /api/plan/history → read from DB only (no LLM).

6.7 Commit messages

When generating git commits, use natural, meaningful messages based on the changes, e.g.:

"add LangChain coach and review agents"

"implement weekly plan orchestrator and shopping list builder"

"create dashboard layout with profile, plans, groceries tabs"

7. LLM Usage & Cost-Safety Instructions

Important: this project must use cost-efficient models by default and avoid accidentally calling expensive models.

7.1 Models to use

Coach Agent (plan generation & regeneration)

Use: gpt-5-mini

This is the default model for all WeeklyPlan generation.

Review Agent (interpreting user actions into ReviewInstruction)

Use: gpt-5-nano by default.

It’s allowed to upgrade this to gpt-5-mini later if needed, but start with nano.

Do NOT use gpt-5.1, gpt-5-pro, or o3/o4 in this project

Those are too expensive for this use case and must not be used in any default path.

7.2 Env-based model configuration

Create a shared LLM client in src/llm/llmClient.ts that reads the model from environment variables, with safe defaults: